<?php
// $Id$

/**
 * @file
 * Add button to publish or unpublish a node,
 * with access control based on the node type
 */

/**
 * Implementation of hook_menu().
 *
 * @see publishcontent_install()
 */
function publishcontent_menu($may_cache) {
  $items = array();
  if (!$may_cache && arg(0) == 'node' && is_numeric(arg(1))) {
    $node = node_load(arg(1));
    if ($node->nid &&
        (user_access('un/publish '. check_plain($node->type) .' content') ||
         user_access('un/publish *all* content'))) {
      $items[] = array('path' => 'node/'. arg(1) .'/'. ($node->status ? 'unpublish' : 'publish'),
        'title' => t($node->status ? 'Unpublish' : 'Publish'),
        'callback' => 'publishcontent_toggle_status',
        'callback arguments' => array($node),
        'access' => TRUE,
        'weight' => 5,
        'type' => MENU_LOCAL_TASK,
      );
      // force the access to the node 
      if (!user_access('administer nodes')) {
        $items[] = array(
          'path' => 'node/'. arg(1),
          'title' => t('View'),
          'callback' => 'node_page_view',
          'callback arguments' => array($node),
          'access' => TRUE,
          'type' => MENU_CALLBACK,
        );
      }
    }
  }
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function publishcontent_perm() {
  $perms = array('un/publish *all* content');

  foreach (node_get_types() as $type) {
    if ($type->module == 'node') {
      $perms[] = 'un/publish '. check_plain($type->type) .' content';
    }
  }
  return $perms;
}

function _publishcontent_get_message($nid, $title, $status) {
  return t($status ? '"@title" [@nid] has been published'
                         : '"@title" [@nid] has been unpublished',
           array('@title' => $title, '@nid' => $nid));
}
/**
 * @param $node a node object
 */
function publishcontent_toggle_status($node) {
  $node->status = !$node->status;
  node_save($node);
  drupal_set_message(_publishcontent_get_message($node->nid, $node->title, $node->status));
  drupal_goto('node/'. $node->nid);
}

/**
 * Implementation of hook_simpletest().
 */
function publishcontent_simpletest() {
  $dir = drupal_get_path('module', 'publishcontent') .'/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}


/**
 * Implementation of hook_views_tables_alter().
 * implements a a link to un/publish for views
 */
function publishcontent_views_tables_alter(&$tables) {
  $tables['node']['fields']['publish'] = array(
    'name' => t('Node: Publish link'),
    'handler' => array(
      'publishcontent_views_handler_node_publish_destination' => t('Return To View'),
      'publishcontent_views_handler_node_publish' => t('Return to Node')
    ),
    'notafield' => TRUE,
    'addlfields' => array('type', 'uid', 'status'),
    'option' => 'string',
    'help' => t('Display a link to publish the node. Enter the text of this link into the option field; if blank the default "Publish" will be used.'),
  );
}

/**
 * display a link to publish a node
 */
function publishcontent_views_handler_node_publish($fieldinfo, $fielddata, $value, $data, $destination = NULL) {
  // try to build a fake node object
  $data->type = $data->node_type;
  $data->uid = $data->node_uid;
  $data->status = $data->node_status;

  if (user_access('un/publish '. check_plain($data->type) .' content') ||
      user_access('un/publish *all* content')) {
    return l(t($data->status ? 'Unpublish' : 'Publish'),
             "node/$data->nid/". ($data->status ? 'unpublish' : 'publish'),
             NULL, $destination);
  }
}

/**
 * display a link to edit a node with a destination return
 */
function publishcontent_views_handler_node_publish_destination($fieldinfo, $fielddata, $value, $data) {
  return publishcontent_views_handler_node_publish($fieldinfo, $fielddata, $value, $data, drupal_get_destination());
}
